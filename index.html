<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>F1 Grand Prix - Real Tracks</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; justify-content: center; align-items: center; }
        .panel { 
            width: 350px; background: rgba(15, 15, 15, 0.98); border: 2px solid #e10600; 
            color: white; padding: 25px; pointer-events: all; border-radius: 8px; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #hud { position: absolute; top: 20px; left: 20px; width: 220px; display: none; pointer-events: none; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .stat-label { font-size: 11px; color: #aaa; }
        .stat-val { font-size: 18px; font-weight: bold; }
        
        #lights-container { position: absolute; top: 5%; left: 50%; transform: translateX(-50%); background: #111; padding: 15px; border-radius: 10px; display: none; border: 4px solid #333; z-index: 100; }
        .light-row { display: flex; gap: 15px; }
        .bulb { width: 40px; height: 40px; background: #222; border-radius: 50%; }
        .bulb.red { background: #ff0000; box-shadow: 0 0 30px #ff0000; }
        button { width: 100%; background: #e10600; color: white; border: none; padding: 15px; font-weight: bold; cursor: pointer; margin-top: 15px; font-size: 16px; border-radius: 4px; }
        label { display: block; margin-top: 12px; font-size: 12px; color: #aaa; }
        select, input { width: 100%; padding: 12px; margin: 5px 0 10px 0; background: #222; color: white; border: 1px solid #444; border-radius: 4px; box-sizing: border-box; }
        #loading-screen { position: absolute; width: 100%; height: 100%; background: #000; color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #results-screen { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.9); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; pointer-events: all; }
        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h2 style="color: #e10600">CONSTRUINDO PISTA...</h2>
        <p>Carregando asfalto...</p>
    </div>

    <div id="results-screen">
        <h1 style="color: #e10600">CORRIDA ENCERRADA</h1>
        <div id="podium" style="background: #222; padding: 20px; border-radius: 10px; width: 300px; text-align: left;"></div>
        <button onclick="location.reload()">NOVA CORRIDA</button>
    </div>

    <div id="ui-layer">
        <div class="panel" id="menu-setup">
            <h2 style="color: #e10600; margin-top: 0; text-align: center;">F1 GP SETUP</h2>
            
            <label>SEU NOME:</label>
            <input type="text" id="playerName" placeholder="Ex: Senna">

            <label>PISTA:</label>
            <select id="trackSelect">
                <option value="oval">Indianapolis (Oval Clássico)</option>
                <option value="bahrain" selected>Bahrein GP (Traçado Real)</option>
            </select>

            <label>EQUIPE:</label>
            <select id="teamSelect"></select>
            
            <label>VOLTAS:</label>
            <select id="lapLimit">
                <option value="1">1 Volta</option>
                <option value="3" selected>3 Voltas</option>
                <option value="5">5 Voltas</option>
            </select>

            <button onclick="startGame()">IR PARA A PISTA</button>
        </div>
    </div>

    <div id="hud" class="panel">
        <div class="stat-row">
            <div><div class="stat-label">POSIÇÃO</div><div class="stat-val"><span id="posTxt">1</span> <span style="font-size:12px; color:#666">/ 20</span></div></div>
            <div style="text-align: right"><div class="stat-label">VOLTA</div><div class="stat-val"><span id="lapTxt">1</span> / <span id="totalLapTxt">3</span></div></div>
        </div>
        <hr style="border: 0; border-top: 1px solid #333; margin: 10px 0;">
        <div class="stat-row">
            <div><div class="stat-label">TEMPO</div><div class="stat-val" id="timerTxt">00:00.0</div></div>
        </div>
        <div class="stat-row" style="margin-top: 10px">
            <div><div class="stat-label">MARCHA</div><div class="stat-val" style="color:#e10600">M<span id="gearTxt">1</span></div></div>
            <div style="text-align: right"><div class="stat-label">VELOCIDADE</div><div class="stat-val"><span id="speedTxt">0</span> KM/H</div></div>
        </div>
    </div>

    <div id="lights-container">
        <div class="light-row">
            <div id="L1" class="bulb"></div><div id="L2" class="bulb"></div>
            <div id="L3" class="bulb"></div><div id="L4" class="bulb"></div>
            <div id="L5" class="bulb"></div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const TEAMS = [
            { name: "FERRARI", color: 0xe10600 }, { name: "MERCEDES", color: 0x00d2be },
            { name: "RED BULL", color: 0x0600ef }, { name: "MCLAREN", color: 0xff8700 },
            { name: "ASTON MARTIN", color: 0x006f62 }, { name: "ALPINE", color: 0x0093cc }
        ];

        const AI_NAMES = ["Verstappen", "Hamilton", "Leclerc", "Norris", "Alonso", "Sainz", "Perez", "Russell", "Piastri", "Gasly", "Stroll", "Hulkenberg", "Albon", "Ricciardo", "Bottas", "Magnussen", "Tsunoda", "Zhou", "Sargeant"];

        // --- DEFINIÇÃO DOS TRAÇADOS ---
        const TRACK_LAYOUTS = {
            oval: (() => {
                // Cria um círculo perfeito via pontos
                const points = [];
                for(let i=0; i<=60; i++) {
                    const a = (i/60) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(a)*300, 0, Math.sin(a)*300));
                }
                return points;
            })(),
            bahrain: [
                // Reta Principal
                new THREE.Vector3( -200, 0, 300 ), new THREE.Vector3( 200, 0, 300 ),
                // T1 (Curva fechada direita)
                new THREE.Vector3( 300, 0, 300 ), new THREE.Vector3( 300, 0, 200 ),
                // T2/T3 (Sinuoso)
                new THREE.Vector3( 200, 0, 150 ), new THREE.Vector3( 100, 0, 200 ),
                // T4 (Rápida)
                new THREE.Vector3( 0, 0, 100 ), new THREE.Vector3( -50, 0, 50 ),
                // Miolo travado
                new THREE.Vector3( -50, 0, -50 ), new THREE.Vector3( 100, 0, -100 ),
                new THREE.Vector3( 150, 0, -200 ), 
                // Reta oposta
                new THREE.Vector3( -100, 0, -300 ), new THREE.Vector3( -300, 0, -200 ),
                // Reta final para fechar o loop
                new THREE.Vector3( -300, 0, 200 ), new THREE.Vector3( -200, 0, 300 )
            ]
        };

        let scene, camera, renderer, player, cachedModel;
        let cars = [], raceStatus = 'preparing';
        let startTime = 0, maxLaps = 3, finishOrder = [];
        const keys = {};

        // Variáveis de Pista e Física
        let trackCurve, trackLength;
        let currentGear = 1;
        const GEAR_LIMITS = [0, 80, 120, 160, 180, 230, 250, 270, 300]; 
        const ACCEL_POWER = 0.55; 
        const MODEL_URL = 'f1model.glb'; 

        const teamSel = document.getElementById('teamSelect');
        TEAMS.forEach((t, i) => teamSel.add(new Option(t.name, i)));

        async function startGame() {
            const nameInput = document.getElementById('playerName').value;
            if(!nameInput) { alert("Insira seu nome!"); return; }
            
            maxLaps = parseInt(document.getElementById('lapLimit').value);
            const selectedTrack = document.getElementById('trackSelect').value;
            
            document.getElementById('totalLapTxt').innerText = maxLaps;
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex';

            initRenderer();
            await loadAssets();
            
            // Gerar a pista baseada na escolha
            buildWorld(selectedTrack);

            const userTeamIdx = document.getElementById('teamSelect').value;
            
            // Configurar Grid
            for(let i=0; i < 20; i++) {
                const isUser = (i === 0);
                const team = isUser ? TEAMS[userTeamIdx] : TEAMS[i % TEAMS.length];
                const car = createCar(team.color, isUser);
                
                // Posição no Grid (Baseado na curva)
                // Começamos um pouco antes do início (progress 0.98, 0.97...)
                const startProgress = 0.98 - (i * 0.006); 
                const point = trackCurve.getPointAt(startProgress % 1);
                const tangent = trackCurve.getTangentAt(startProgress % 1);
                
                // Calcular lateral (Lane)
                const side = (i % 2 === 0) ? 4 : -4;
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize().multiplyScalar(side);
                
                car.position.copy(point).add(normal);
                car.lookAt(point.clone().add(tangent.multiplyScalar(10))); // Olhar para frente da pista

                car.userData = { 
                    speed: 0, 
                    isPlayer: isUser, 
                    laneOffset: side, // Offset lateral da linha central
                    name: isUser ? nameInput : AI_NAMES[i-1],
                    laps: 0,
                    finished: false,
                    trackProgress: startProgress, // 0 a 1
                    totalProgress: 0,
                    lastProgress: startProgress
                };
                
                scene.add(car);
                if(isUser) player = car;
                else cars.push(car);
            }

            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            startCountdown();
        }

        function initRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
        }

        async function loadAssets() {
            const loader = new GLTFLoader();
            try {
                const gltf = await loader.loadAsync(MODEL_URL);
                cachedModel = gltf.scene;
                cachedModel.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
            } catch(e) { console.warn("Usando fallback box"); }
        }

        function buildWorld(trackType) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 100, 900);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            scene.add(sun);

            // Chão (Grama)
            const grass = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshLambertMaterial({color: 0x3b7d32}));
            grass.rotation.x = -Math.PI/2;
            scene.add(grass);

            // CRIAR A PISTA USANDO CURVAS
            const points = TRACK_LAYOUTS[trackType];
            trackCurve = new THREE.CatmullRomCurve3(points, true); // true = fechada (loop)
            trackLength = trackCurve.getLength();

            // Geometria da Pista (Tubo achatado para parecer asfalto)
            const trackGeo = new THREE.TubeGeometry(trackCurve, 200, 12, 8, true);
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const trackMesh = new THREE.Mesh(trackGeo, trackMat);
            trackMesh.scale.y = 0.05; // Achata o tubo
            trackMesh.position.y = 0.2;
            scene.add(trackMesh);

            // Zebras (Visual simples: um tubo um pouco maior colorido)
            const kerbGeo = new THREE.TubeGeometry(trackCurve, 200, 13, 8, true);
            const kerbMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const kerbMesh = new THREE.Mesh(kerbGeo, kerbMat);
            kerbMesh.scale.y = 0.04;
            kerbMesh.position.y = 0.15;
            scene.add(kerbMesh);
        }

        function createCar(color, isPlayer) {
            const group = new THREE.Group();
            if (cachedModel) {
                const model = cachedModel.clone();
                model.position.y = 0.5;
                model.traverse(child => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        if (child.name.toLowerCase().includes("body") || child.name.toLowerCase().includes("paint")) {
                            child.material.color.set(color);
                        }
                    }
                });
                group.add(model);
            } else {
                const box = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.6, 4), new THREE.MeshLambertMaterial({color}));
                box.position.y = 0.3; group.add(box);
            }
            return group;
        }

        function startCountdown() {
            const container = document.getElementById('lights-container');
            container.style.display = 'block';
            let lit = 0;
            const timer = setInterval(() => {
                lit++;
                if(lit <= 5) document.getElementById(`L${lit}`).classList.add('red');
                else {
                    clearInterval(timer);
                    setTimeout(() => {
                        document.querySelectorAll('.bulb').forEach(b => b.classList.remove('red'));
                        raceStatus = 'racing';
                        startTime = Date.now();
                        setTimeout(() => container.style.display = 'none', 2000);
                    }, 1500);
                }
            }, 1000);
            animate();
        }

        function handleCollisions() {
            const allCars = [player, ...cars];
            // Ajustado para coordenadas globais
            for (let i = 0; i < allCars.length; i++) {
                for (let j = i + 1; j < allCars.length; j++) {
                    const c1 = allCars[i], c2 = allCars[j];
                    if(c1.userData.finished || c2.userData.finished) continue;
                    
                    const dist = c1.position.distanceTo(c2.position);
                    if (dist < 3.5) {
                        // Empurra baseado na posição atual
                        const dir = new THREE.Vector3().subVectors(c1.position, c2.position).normalize();
                        const push = dir.multiplyScalar(0.2);
                        c1.position.add(push);
                        c2.position.sub(push);
                        
                        // Perda de velocidade
                        c1.userData.speed *= 0.8;
                        c2.userData.speed *= 0.8;
                        // Força troca de lane para desviar
                        c1.userData.laneOffset += 1;
                    }
                }
            }
        }

        // --- NOVA LÓGICA DE MOVIMENTO: SEGUIR A CURVA ---
        function moveCarOnTrack(car, inputSpeed, turnInput) {
            // Converter velocidade linear para progresso na curva (0 a 1)
            // Velocidade arbitraria ajustada para o tamanho da pista
            const speedProgress = (inputSpeed * 2.5) / trackLength; 
            
            car.userData.trackProgress += speedProgress;
            
            // Controle lateral (A/D)
            if (turnInput !== 0 && car.userData.speed > 0.01) {
                car.userData.laneOffset -= turnInput * 0.5; // Invertido para A ser esquerda
                // Limite da pista
                car.userData.laneOffset = Math.max(-15, Math.min(15, car.userData.laneOffset));
            }

            // Normalizar Loop (0 a 1)
            if (car.userData.trackProgress >= 1) {
                car.userData.trackProgress -= 1;
            }

            // Obter posição na curva
            const point = trackCurve.getPointAt(car.userData.trackProgress);
            const tangent = trackCurve.getTangentAt(car.userData.trackProgress);

            // Calcular vetor "Direita" da pista para aplicar o offset lateral
            const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            const finalPos = point.clone().add(normal.multiplyScalar(car.userData.laneOffset));
            
            car.position.set(finalPos.x, finalPos.y, finalPos.z);
            
            // Rotacionar carro para olhar para frente (LookAt num ponto futuro)
            const lookPoint = trackCurve.getPointAt((car.userData.trackProgress + 0.01) % 1);
            // Ajustar o lookPoint com o mesmo offset lateral para ele não olhar pro centro da pista
            const lookOffset = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize().multiplyScalar(car.userData.laneOffset);
            car.lookAt(lookPoint.add(lookOffset));
            
            // Checar Voltas
            checkLap(car);
        }

        function update() {
            if(raceStatus === 'preparing') return;

            if(raceStatus === 'racing') {
                const diff = new Date(Date.now() - startTime);
                document.getElementById('timerTxt').innerText = diff.toISOString().substr(14, 7);
                updateRanking();
            }

            // --- PLAYER ---
            let speedKmh = player.userData.speed * 320;
            if(keys['w'] && !player.userData.finished) {
                for(let i=1; i<=8; i++) { if(speedKmh < GEAR_LIMITS[i]) { currentGear = i; break; } }
                let accelMult = (speedKmh > 300) ? 0.2 : 1.0;
                player.userData.speed += (ACCEL_POWER * accelMult) * 0.001; // Ajustado para nova escala
            }
            player.userData.speed *= 0.99; // Atrito
            if(keys['s']) player.userData.speed -= 0.005;
            player.userData.speed = Math.max(0, player.userData.speed);

            const turn = (keys['a'] ? 1 : 0) - (keys['d'] ? 1 : 0);
            moveCarOnTrack(player, player.userData.speed, turn);

            // --- AI ---
            cars.forEach(ai => {
                if(ai.userData.finished) return;
                
                // IA Básica: Acelera e tenta manter a lane
                let targetSpeed = 0.8 + (Math.random() * 0.1);
                // Diminuir velocidade em curvas (simulado pela curvatura ou aleatório)
                ai.userData.speed += (targetSpeed - ai.userData.speed) * 0.02;
                
                // IA tenta voltar para o centro ou ultrapassar devagar
                if(Math.random() > 0.95) ai.userData.laneOffset += (Math.random()-0.5);
                
                moveCarOnTrack(ai, ai.userData.speed * 0.001, 0);
            });

            handleCollisions();

            document.getElementById('speedTxt').innerText = Math.floor(player.userData.speed * 32000); // Ajuste visual escala
            document.getElementById('gearTxt').innerText = currentGear;
        }

        function checkLap(car) {
            // Detectar virada de 0.99 para 0.01
            // Usamos uma lógica simples: se o progresso caiu drasticamente, completou volta
            if (car.userData.lastProgress > 0.9 && car.userData.trackProgress < 0.1) {
                car.userData.laps++;
                if(car.userData.isPlayer) {
                    document.getElementById('lapTxt').innerText = Math.min(car.userData.laps + 1, maxLaps);
                }
                if(car.userData.laps >= maxLaps && !car.userData.finished) {
                    car.userData.finished = true;
                    finishOrder.push(car.userData.name);
                    if(car.userData.isPlayer) endRace();
                }
            }
            car.userData.lastProgress = car.userData.trackProgress;
            car.userData.totalProgress = car.userData.laps + car.userData.trackProgress;
        }

        function updateRanking() {
            const allParticipants = [player, ...cars];
            const sorted = allParticipants.sort((a, b) => b.userData.totalProgress - a.userData.totalProgress);
            const playerPos = sorted.findIndex(c => c.userData.isPlayer) + 1;
            document.getElementById('posTxt').innerText = playerPos;
        }

        function endRace() {
            raceStatus = 'finished';
            const podium = document.getElementById('podium');
            podium.innerHTML = "<h3 style='margin-top:0'>RESULTADOS:</h3>";
            finishOrder.slice(0, 10).forEach((name, i) => {
                const color = i===0 ? '#FFD700' : (i===1 ? '#C0C0C0' : (i===2 ? '#CD7F32' : '#fff'));
                podium.innerHTML += `<div style="color:${color}; margin:5px 0;">${i+1}º - ${name}</div>`;
            });
            document.getElementById('results-screen').style.display = 'flex';
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            if(player && trackCurve) {
                // Camera Follow mais suave
                const relPos = new THREE.Vector3(0, 5, -15);
                relPos.applyQuaternion(player.quaternion);
                const targetPos = player.position.clone().add(relPos);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(player.position);
            }
            renderer.render(scene, camera);
        }

        window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
        window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;
        window.startGame = startGame;
    </script>
</body>
</html>
